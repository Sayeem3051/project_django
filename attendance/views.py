from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.utils import timezone
from django.http import JsonResponse, HttpResponse
from django.db.models import Q, Count
from .models import Attendance, AttendanceLog, DailyAttendanceNotification, AttendanceStatus
from .forms import AttendanceForm, ManualAttendanceForm, DateRangeForm
from datetime import date, timedelta, datetime
import csv

@login_required
def attendance_home(request):
    """Attendance home page"""
    today = timezone.now().date()
    today_attendance = Attendance.objects.filter(user=request.user, date=today).first()
    
    context = {
        'today': today,
        'attendance': today_attendance,
    }
    
    return render(request, 'attendance/home.html', context)

@login_required
def mark_attendance(request):
    """Mark attendance view"""
    today = timezone.now().date()
    now = timezone.now()
    
    # Check if attendance record exists for today
    attendance, created = Attendance.objects.get_or_create(
        user=request.user,
        date=today,
        defaults={'check_in_time': now, 'attendance_type': 'student'}
    )
    
    if request.method == 'POST':
        form = AttendanceForm(request.POST, instance=attendance)
        verification_method = request.POST.get('verification_method', 'manual')
        
        if form.is_valid():
            # Handle face verification
            if verification_method == 'face':
                if 'face_image' in request.FILES:
                    # Use the face recognition system
                    from .face_recognition_utils import process_uploaded_image, detect_faces, extract_face_features, verify_face
                    
                    # Process the uploaded face image
                    image_array = process_uploaded_image(request.FILES['face_image'])
                    if image_array is not None:
                        # Detect faces in the image
                        face_locations = detect_faces(image_array)
                        
                        if not face_locations:
                            messages.error(request, 'No face detected in the image. Please try again.')
                            context = {
                                'form': form,
                                'attendance': attendance,
                                'created': created,
                            }
                            return render(request, 'attendance/mark_attendance.html', context)
                        
                        if len(face_locations) > 1:
                            messages.error(request, 'Multiple faces detected. Please ensure only your face is visible.')
                            context = {
                                'form': form,
                                'attendance': attendance,
                                'created': created,
                            }
                            return render(request, 'attendance/mark_attendance.html', context)
                        
                        # Extract face features
                        face_features = extract_face_features(image_array, face_locations)
                        
                        if not face_features:
                            messages.error(request, 'Could not extract facial features. Please try again.')
                            context = {
                                'form': form,
                                'attendance': attendance,
                                'created': created,
                            }
                            return render(request, 'attendance/mark_attendance.html', context)
                        
                        # Verify the face
                        is_match, confidence, message = verify_face(request.user, face_features[0])
                        
                        if is_match:
                            verification_method = 'face'
                        else:
                            messages.error(request, f'Face verification failed: {message}')
                            context = {
                                'form': form,
                                'attendance': attendance,
                                'created': created,
                                'verification_failed': True,
                                'verification_message': message
                            }
                            return render(request, 'attendance/mark_attendance.html', context)
                    else:
                        messages.error(request, 'Face verification failed. Please try again or enable face recognition in your profile.')
                        context = {
                            'form': form,
                            'attendance': attendance,
                            'created': created,
                        }
                        return render(request, 'attendance/mark_attendance.html', context)
                else:
                    messages.error(request, 'Face verification failed. Please try again.')
                    context = {
                        'form': form,
                        'attendance': attendance,
                        'created': created,
                    }
                    return render(request, 'attendance/mark_attendance.html', context)
            
            # If attendance record already exists and has check_in_time but no check_out_time
            if not created and attendance.check_in_time and not attendance.check_out_time:
                attendance.check_out_time = now
                attendance.notes = form.cleaned_data.get('notes', '')
                if verification_method == 'face':
                    attendance.attendance_type = 'face'
                attendance.save()
                
                # Create attendance log for check-out
                AttendanceLog.objects.create(
                    user=request.user,
                    log_type='check_out',
                    verification_method=verification_method,
                    ip_address=request.META.get('REMOTE_ADDR'),
                    device_info=request.META.get('HTTP_USER_AGENT', '')[:255]
                )
                
                messages.success(request, f'Check-out recorded successfully using {verification_method} verification!')
            else:
                attendance_form = form.save(commit=False)
                if verification_method == 'face':
                    attendance_form.attendance_type = 'face'
                attendance_form.save()
                
                # Create attendance log for check-in if this is a new record
                if created:
                    AttendanceLog.objects.create(
                        user=request.user,
                        log_type='check_in',
                        verification_method=verification_method,
                        ip_address=request.META.get('REMOTE_ADDR'),
                        device_info=request.META.get('HTTP_USER_AGENT', '')[:255]
                    )
                
                messages.success(request, f'Attendance updated successfully using {verification_method} verification!')
            
            return redirect('attendance:attendance_home')
    else:
        form = AttendanceForm(instance=attendance)
    
    context = {
        'form': form,
        'attendance': attendance,
        'created': created,
        'face_recognition_enabled': hasattr(request.user, 'profile') and request.user.profile.face_recognition_enabled
    }
    
    return render(request, 'attendance/mark_attendance.html', context)

@login_required
def attendance_history(request):
    """View attendance history"""
    # Default to current month
    today = timezone.now().date()
    start_date = date(today.year, today.month, 1)
    end_date = (date(today.year, today.month + 1, 1) 
                if today.month < 12 
                else date(today.year + 1, 1, 1)) - timedelta(days=1)
    
    # Get students list for staff users
    students = None
    if request.user.is_staff:
        students = User.objects.filter(is_active=True).order_by('username')
    
    # Process GET parameters for filtering
    if request.method == 'GET':
        form = DateRangeForm(request.GET)
        if form.is_valid():
            start_date = form.cleaned_data.get('start_date', start_date)
            end_date = form.cleaned_data.get('end_date', end_date)
            selected_user = form.cleaned_data.get('user')
        else:
            form = DateRangeForm(initial={'start_date': start_date, 'end_date': end_date})
            selected_user = None
    else:
        form = DateRangeForm(initial={'start_date': start_date, 'end_date': end_date})
        selected_user = None
    
    # Filter attendance records
    if request.user.is_staff and selected_user:
        attendance_list = Attendance.objects.filter(
            user=selected_user,
            date__gte=start_date,
            date__lte=end_date
        ).order_by('-date')
    elif request.user.is_staff and not selected_user:
        attendance_list = Attendance.objects.filter(
            date__gte=start_date,
            date__lte=end_date
        ).order_by('-date')
    else:
        attendance_list = Attendance.objects.filter(
            user=request.user,
            date__gte=start_date,
            date__lte=end_date
        ).order_by('-date')
    
    # Pagination
    from django.core.paginator import Paginator
    paginator = Paginator(attendance_list, 10)  # Show 10 records per page
    page = request.GET.get('page')
    try:
        attendance_records = paginator.page(page)
    except:
        # If page is not an integer or out of range, deliver first page
        attendance_records = paginator.page(1)
    
    context = {
        'form': form,
        'attendance_records': attendance_records,
        'start_date': start_date,
        'students': students,
        'end_date': end_date,
    }
    
    return render(request, 'attendance/history.html', context)

@login_required
def attendance_report(request):
    """Generate attendance report"""
    if not request.user.is_staff and not request.user.is_superuser:
        messages.error(request, 'You do not have permission to access this page.')
        return redirect('users:dashboard')
    
    # Get students list for staff users
    students = User.objects.filter(is_active=True).order_by('username')
    
    # Default to current month
    today = timezone.now().date()
    start_date = date(today.year, today.month, 1)
    end_date = today
    
    preview = False
    attendance_records = []
    summary_data = []
    download_url = None
    
    if request.method == 'GET' and request.GET:
        form = DateRangeForm(request.GET)
        if form.is_valid():
            start_date = form.cleaned_data.get('start_date', start_date)
            end_date = form.cleaned_data.get('end_date', end_date)
            selected_user = form.cleaned_data.get('user')
            report_type = request.GET.get('report_type', 'detailed')
            report_format = request.GET.get('format', 'csv')
            
            # Filter attendance records
            query = Q(date__gte=start_date) & Q(date__lte=end_date)
            if selected_user:
                query &= Q(user=selected_user)
            
            attendance_records = Attendance.objects.filter(query).order_by('user__username', 'date')
            
            # Generate preview if requested
            if 'preview' in request.GET:
                preview = True
                
                # Generate summary data if summary report type is selected
                if report_type == 'summary':
                    # This is a simplified example - in a real app, you'd calculate these metrics
                    summary_data = []
                    if selected_user:
                        users = [selected_user]
                    else:
                        users = User.objects.filter(attendance__in=attendance_records).distinct()
                    
                    for user in users:
                        user_records = attendance_records.filter(user=user)
                        present_days = user_records.filter(is_present=True).count()
                        total_days = user_records.count()
                        
                        total_hours = sum([r.get_duration_hours() for r in user_records if r.check_in_time and r.check_out_time], 0)
                        avg_hours = total_hours / present_days if present_days > 0 else 0
                        
                        summary_data.append({
                            'user': user,
                            'total_days': total_days,
                            'present_days': present_days,
                            'absent_days': total_days - present_days,
                            'late_arrivals': 0,  # Would calculate based on company policy
                            'early_departures': 0,  # Would calculate based on company policy
                            'total_hours': round(total_hours, 2),
                            'avg_hours_per_day': round(avg_hours, 2)
                        })
                
                # Create download URL for the actual report
                params = request.GET.copy()
                params.pop('preview', None)
                download_url = f"{request.path}?{params.urlencode()}"
            
            # Generate actual report file if not preview
            elif report_format == 'csv':
                response = HttpResponse(content_type='text/csv')
                response['Content-Disposition'] = f'attachment; filename="attendance_report_{start_date}_to_{end_date}.csv"'
                
                writer = csv.writer(response)
                
                if report_type == 'detailed':
                    writer.writerow(['Username', 'Employee ID', 'Date', 'Check-in Time', 'Check-out Time', 'Duration', 'Type', 'Status', 'Notes'])
                    
                    for record in attendance_records:
                        writer.writerow([
                            record.user.username,
                            getattr(record.user.profile, 'employee_id', 'N/A') if hasattr(record.user, 'profile') else 'N/A',
                            record.date,
                            record.check_in_time.strftime('%H:%M:%S') if record.check_in_time else 'N/A',
                            record.check_out_time.strftime('%H:%M:%S') if record.check_out_time else 'N/A',
                            record.get_duration(),
                            record.attendance_type,
                            'Present' if record.is_present else 'Absent',
                            record.notes or 'N/A'
                        ])
                else:  # summary report
                    writer.writerow(['Username', 'Employee ID', 'Total Days', 'Present Days', 'Absent Days', 'Total Hours', 'Avg Hours/Day'])
                    
                    # Generate summary data
                    if selected_user:
                        users = [selected_user]
                    else:
                        users = User.objects.filter(attendance__in=attendance_records).distinct()
                    
                    for user in users:
                        user_records = attendance_records.filter(user=user)
                        present_days = user_records.filter(is_present=True).count()
                        total_days = user_records.count()
                        
                        total_hours = sum([r.get_duration_hours() for r in user_records if r.check_in_time and r.check_out_time], 0)
                        avg_hours = total_hours / present_days if present_days > 0 else 0
                        
                        writer.writerow([
                            user.username,
                            getattr(user.profile, 'employee_id', 'N/A') if hasattr(user, 'profile') else 'N/A',
                            total_days,
                            present_days,
                            total_days - present_days,
                            round(total_hours, 2),
                            round(avg_hours, 2)
                        ])
                
                return response
            
            # Handle Excel and PDF formats (placeholder - would implement with appropriate libraries)
            elif report_format in ['excel', 'pdf']:
                messages.info(request, f'{report_format.upper()} export is not implemented in this demo.')
                return redirect('attendance:attendance_report')
    else:
        form = DateRangeForm(initial={'start_date': start_date, 'end_date': end_date})
    
    context = {
        'form': form,
        'attendance_records': attendance_records,
        'summary_data': summary_data,
        'preview': preview,
        'download_url': download_url,
        'students': students,
        'start_date': start_date,
        'end_date': end_date,
    }
    
    return render(request, 'attendance/report.html', context)

@login_required
def upload_face(request):
    """Upload face image for recognition"""
    from .face_recognition_utils import process_uploaded_image, detect_faces, extract_face_features, save_face_encoding
    
    if request.method == 'POST':
        if 'face_image' in request.FILES:
            # Validate file type
            file = request.FILES['face_image']
            if not file.content_type.startswith('image/'):
                messages.error(request, 'Please upload a valid image file.')
                return render(request, 'attendance/upload_face.html')
            
            # Check file size (5MB limit)
            if file.size > 5 * 1024 * 1024:
                messages.error(request, 'File size must be less than 5MB.')
                return render(request, 'attendance/upload_face.html')
            
            # Process the uploaded image for face recognition
            image_array = process_uploaded_image(file)
            if image_array is None:
                messages.error(request, 'Could not process the uploaded image. Please try again with a different image.')
                return render(request, 'attendance/upload_face.html')
            
            # Detect faces in the image
            face_locations = detect_faces(image_array)
            
            if not face_locations:
                messages.error(request, 'No face detected in the uploaded image. Please upload a clear image of your face.')
                return render(request, 'attendance/upload_face.html')
            
            if len(face_locations) > 1:
                messages.error(request, 'Multiple faces detected in the image. Please upload an image with only your face.')
                return render(request, 'attendance/upload_face.html')
            
            # Extract face features
            face_features = extract_face_features(image_array, face_locations)
            
            if not face_features:
                messages.error(request, 'Could not extract facial features. Please upload a clearer image.')
                return render(request, 'attendance/upload_face.html')
            
            # Save the face image
            request.user.profile.face_image = file
            
            # Save the face features
            if save_face_encoding(request.user, face_features[0]):
                # Enable face recognition for this user
                request.user.profile.face_recognition_enabled = True
                request.user.profile.save()
                messages.success(request, 'Face image uploaded and processed successfully! Face recognition is now enabled for your account.')
            else:
                request.user.profile.save()
                messages.warning(request, 'Face image uploaded but there was an issue processing the facial features. Face recognition may not work properly.')
            
            return redirect('users:profile')
        else:
            messages.error(request, 'No image file provided.')
    
    return render(request, 'attendance/upload_face.html')

@login_required
def upload_fingerprint(request):
    """Upload fingerprint data"""
    if request.method == 'POST':
        if 'fingerprint_data' in request.FILES:
            request.user.profile.fingerprint_data = request.FILES['fingerprint_data']
            request.user.profile.save()
            messages.success(request, 'Fingerprint data uploaded successfully!')
            return redirect('users:profile')
        else:
            messages.error(request, 'No fingerprint data provided.')
    
    return render(request, 'attendance/upload_fingerprint.html')

@login_required
def test_camera(request):
    """Test camera functionality"""
    return render(request, 'attendance/test_camera.html')

@login_required
def debug_camera(request):
    """Debug camera functionality"""
    return render(request, 'attendance/debug_camera.html')

@login_required
def notification_dashboard(request):
    """Admin notification dashboard showing daily attendance status"""
    if not request.user.is_staff:
        messages.error(request, 'Access denied. Admin privileges required.')
        return redirect('dashboard')
    
    today = date.today()
    
    # Get today's attendance status
    today_attendance = AttendanceStatus.objects.filter(date=today)
    
    # Get all users and their attendance status
    all_students = User.objects.filter(is_active=True).exclude(is_superuser=True)
    
    # Create attendance status for students who don't have one for today
    for student in all_students:
        AttendanceStatus.objects.get_or_create(
            user=student,
            date=today,
            defaults={'status': 'absent'}
        )
    
    # Get updated attendance data
    attendance_data = AttendanceStatus.objects.filter(date=today).select_related('user')
    
    # Count statistics
    stats = {
        'total_students': all_students.count(),
        'present': attendance_data.filter(status='present').count(),
        'absent': attendance_data.filter(status='absent').count(),
        'late': attendance_data.filter(status='late').count(),
        'half_day': attendance_data.filter(status='half_day').count(),
        'on_leave': attendance_data.filter(status='leave').count(),
    }
    
    # Get recent notifications
    recent_notifications = DailyAttendanceNotification.objects.filter(
        date__gte=today - timedelta(days=7)
    ).order_by('-created_at')[:10]
    
    # Get unread notifications count
    unread_count = DailyAttendanceNotification.objects.filter(is_read=False).count()
    
    context = {
        'today': today,
        'attendance_data': attendance_data,
        'stats': stats,
        'recent_notifications': recent_notifications,
        'unread_count': unread_count,
    }
    
    return render(request, 'attendance/notification_dashboard.html', context)

@login_required
def mark_attendance_status(request):
    """Mark attendance status for employees"""
    if not request.user.is_staff:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        user_id = request.POST.get('user_id')
        status = request.POST.get('status')
        date_str = request.POST.get('date', date.today().isoformat())
        
        try:
            user = User.objects.get(id=user_id)
            attendance_date = datetime.strptime(date_str, '%Y-%m-%d').date()
            
            attendance_status, created = AttendanceStatus.objects.get_or_create(
                user=user,
                date=attendance_date,
                defaults={'status': status}
            )
            
            if not created:
                attendance_status.status = status
                attendance_status.save()
            
            return JsonResponse({
                'success': True,
                'message': f'Attendance status updated for {user.username}'
            })
            
        except User.DoesNotExist:
            return JsonResponse({'error': 'User not found'}, status=404)
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Invalid request'}, status=400)

@login_required
def create_daily_notification(request):
    """Create daily notification summary"""
    if not request.user.is_staff:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        notification_type = request.POST.get('type', 'daily_summary')
        custom_message = request.POST.get('message', '')
        
        today = date.today()
        
        if notification_type == 'daily_summary':
            stats = {
                'present': AttendanceStatus.objects.filter(date=today, status='present').count(),
                'absent': AttendanceStatus.objects.filter(date=today, status='absent').count(),
                'late': AttendanceStatus.objects.filter(date=today, status='late').count(),
            }
            
            message = f"""
            Daily Attendance Summary for {today}:
            
            ✅ Present: {stats['present']} students
            ❌ Absent: {stats['absent']} students
            ⏰ Late: {stats['late']} students
            
            Total Students: {sum(stats.values())}
            """
        else:
            message = custom_message
        
        notification = DailyAttendanceNotification.objects.create(
            date=today,
            notification_type=notification_type,
            title=f'Daily Summary - {today}',
            message=message
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Notification created successfully',
            'notification_id': notification.id
        })
    
    return JsonResponse({'error': 'Invalid request'}, status=400)

@login_required
def mark_notification_read(request, notification_id):
    """Mark notification as read"""
    if not request.user.is_staff:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        notification = DailyAttendanceNotification.objects.get(id=notification_id)
        notification.is_read = True
        notification.save()
        
        return JsonResponse({'success': True})
    except DailyAttendanceNotification.DoesNotExist:
        return JsonResponse({'error': 'Notification not found'}, status=404)
